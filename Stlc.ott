embed
{{ coq
(** For F_p *)
Require Import Coqprime.elliptic.ZEll.
Require Import Coq.ZArith.Znumtheory.
Require Import Coq.ZArith.BinInt.

Module Stlc_Fp.
  (** Prime  *)
  Variable p: Z.
  Hypothesis p_prime: prime p.

  Definition Fp := pK p.
  Definition fp_one := pkI p.
  Definition fp_zero := pkO p.

  Lemma eq_field: forall (x y : Fp), {x = y} + {x <> y}.
  Proof.
    intros.
    unfold Fp in *.
    unfold pK in *.
    destruct x as (x0, Hx_mod), y as (y0, Hy_mod).
    pose proof (Coq.ZArith.BinInt.Z.eq_dec x0 y0).
    inversion H.
    Check GZnZ.zirr.
    - left. exact (GZnZ.zirr p x0 y0 Hx_mod Hy_mod H0).
    - right. intro. inversion H1. contradiction.
  Qed.
  Hint Resolve eq_field: ott_coq_equality.
  Lemma eq_bool: forall (x y: bool), {x = y} + {x <> y}.
  Proof.
    decide equality; auto.
  Qed.
  Hint Resolve eq_bool: ott_coq_equality.
End Stlc_Fp. }}

metavar expvar, x, y, z ::= {{ repr-locally-nameless }}
  
grammar

n :: fp_ ::=          {{ coq Fp }} {{ coq-equality }}
  | [0]         ::  :: zero {{ coq [[fp_zero]] }}
  | [1]         ::  :: one  {{ coq [[fp_one]] }}			
  | [ n1 + n2 ] ::  :: add  {{ coq (pkplus [[n1]] [[n2]]) }}
  | [ n1 - n2 ] ::  :: sub  {{ coq (pksub [[n1]] [[n2]]) }}
  | [ n1 * n2 ] ::  :: mul  {{ coq (pkmul [[n1]] [[n2]]) }}
  | [ n1 / n2 ] ::  :: div  {{ coq (pkdiv [[n1]] [[n2]]) }}

b :: bool_ ::=  {{ coq  bool }} {{ coq-equality }}
  | true  ::  :: true {{ coq true }}
  | false ::  :: false {{ coq false }}
  
typ, T :: ty_ ::= {{ coq-equality }}
  | bool     ::   :: bool
  | field    ::   :: field
  | T1 * T2  ::   :: prod
  | T1 -> T2 ::   :: arrow

constant, c :: const_ ::= {{ coq-equality }}
  | b     :: :: bool
  | n     :: :: field

op, binop :: op_ ::= {{ coq-equality }}
  | +  :: :: add
  | -  :: :: sub
  | *  :: :: mul
  | /  :: :: div
  | && :: :: and {{ tex \land }}
  | || :: :: or  {{ tex \lor }}
  
exp, e, f, g :: tm_ ::= {{ coq-equality }}
  | x                      ::   :: var
  | \ x : T . e            ::   :: abs (+ bind x in e +)
  | e1 e2                  ::   :: app
  | let x := e1 in e2      ::   :: let (+ bind x in e2 +)
  | constant               ::   :: constant
  | e1 op e2               ::   :: binop
  | e1 == e2               ::   :: eq
  | not e                  ::   :: not
  | if e then e1 else e2   ::   :: ifthenelse
  | { e1 , e2 }            ::   :: pair
  | fst e                  ::   :: proj_1
  | snd e                  ::   :: proj_2
  | cast e                 ::   :: cast
  | ( e )                  :: S :: paren {{ coq ([[e]]) }}
  | { e2 / x } e1          :: M :: subst {{ coq (open_exp_wrt_exp [[x e1]] [[e2]]) }}

substitutions
  single e x :: subst

freevars
  e x :: fv

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

grammar

typing_env, G, F, E :: '' ::= {{ coq list (atom*typ) }}
  | empty     ::   :: empty {{ coq nil }}
  | G , x : T ::   :: cons  {{ coq ((one (pair [[x]] [[T]])) ++ [[G]]) }}


value, v :: value_ ::=
  | \ x : T . e :: :: abs (+ bind x in e +)
  | constant    :: :: constant
  | { v1 , v2 } :: :: pair
  
formula :: formula_ ::=
  | judgement      ::   :: judgement
  | ( x : T ) in G ::   :: binds {{ coq binds ([[x]]) ([[T]]) ([[G]]) }}
  | uniq G         ::   :: uniq  {{ coq uniq ([[G]]) }}
  | c1 <> c2       :: M :: neq {{ coq [[c1]] <> [[c2]] }}
  
subrules
  v <:: e
  
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

defns
Jtyping :: '' ::=

defn
G |- e : T
:: :: typing :: typing_ by

(x:T) in G
uniq G
----------- :: var
G |- x : T

G, x : T1 |- e : T2
------------------------ :: abs
G |- \x:T1.e : T1 -> T2

G |- e1 : T1 -> T2
G |- e2 : T1
------------------- :: app
G |- e1 e2 : T2

------------------ :: true
G |- true: bool

------------------ :: false
G |- false: bool

--------------- :: field
G |- n: field

G |- e1: bool
G |- e2: bool
---------------------- :: boolop
G |- e1 op e2: bool

G |- e: bool
---------------- :: boolnot
G |- not e: bool

G |- e1: field
G |- e2: field
---------------------- :: fieldop
G |- e1 op e2: field

G |- e1: T
G |- e2: T
--------------------- :: eqop
G |- e1 == e2: bool

G |- e: bool
G |- e1: T
G |- e2: T
------------------------------ :: if
G |- if e then e1 else e2 : T

G |- e1: T1
G, x: T1 |- e2: T2
--------------------------- :: let
G |- let x:= e1 in e2 : T2

G |- e1: T1
G |- e2: T2
------------------------ :: pair
G |- { e1, e2 } : T1*T2

G |- e: T1*T2
--------------- :: proj_1
G |- fst e : T1

G |- e: T1*T2
--------------- :: proj_2
G |- snd e : T2

G |- e: bool
---------------------- :: cast
G |- cast e: field

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

defns
Jop :: '' ::=

defn
e1 --> e2
:: :: step :: step_ by

%% Lambda

e1 --> e1'
----------------- :: app_1
e1 e2 --> e1' e2

e2 --> e2'
----------------- :: app_2
v1 e2 --> v1 e2'

----------------------------- :: beta
(\x:T.e1) v2 --> {v2 / x} e1

%% If

--------------------------- :: if_true
if true then e1 else e2 --> e1

--------------------------- :: if_false
if false then e1 else e2 --> e2

%% Bool
------------------ :: not_true
not true --> false

------------------ :: not_false
not false --> true

------------------- :: and_1
(e && true) --> e

------------------- :: and_2
(true && e) --> e

------------------- :: and_3
(e && false) --> false

------------------- :: and_4
(false && e) --> false

------------------- :: or_1
(e1 || true) --> true

------------------- :: or_2
(true || e1) --> true

------------------- :: or_3
(e1 || false) --> e1

------------------- :: or_4
(false || e1) --> e1

%% Let

----------------------------- :: let_v
let x := v1 in e2 -->  { v1 / x } e2 

e1 --> e1'
---------------------------------- :: let_cog
let x := e1 in e2 --> let x := e1' in e2

%% binop
e1 --> e1'
----------------------- :: binop_cog_1
e1 op e2 --> e1' op e2

e2 --> e2'
----------------------- :: binop_cog_2
c1 op e2 --> c1 op e2'

----------------------- :: add_const
n1 + n2 --> [ n1 + n2 ]

----------------------- :: sub_const
n1 - n2 --> [ n1 - n2 ]

----------------------- :: mul_const
n1 * n2 --> [ n1 * n2 ]

n2 <> [0]
----------------------- :: div_const
n1 / n2 --> [ n1 / n2 ]

%% Equality
e1 --> e1'
----------------------- :: eq_cog_1
e1 == e2 --> e1' == e2

e2 --> e2'
----------------------- :: eq_cog_2
c1 == e2 --> c1 == e2'

----------------- :: eq_refl
c == c --> true

c1 <> c2
------------------- :: eq_neq
c1 == c2 --> false

%% Pairs
------------------ :: pair_beta_1
fst { e1, e2 } --> e1

------------------ :: pair_beta_2
snd { e1, e2 } --> e2

e --> e'
------------------ :: proj_cog_1
fst e --> fst e'

e --> e'
------------------ :: proj_cog_2
snd e --> snd e'

e1 --> e1'
--------------------------- :: pair_cog_1
{ e1, e2 } --> { e1', e2 }

e2 --> e2'
--------------------------- :: pair_cog_2
{ e1, e2 } --> { e1, e2' }

%% Casting

------------------------- :: cast_true
cast true --> [1]

------------------------- :: cast_false
cast false --> [0]

e --> e'
-------------------------- :: cast_cog
cast e --> cast e'


